# Story 1.6: Smart Matching Logic

## Status
Done

## Story

**As a** System Administrator,
**I want** a backend service that takes parsed payment data and intelligently suggests potential GHL contact matches,
**so that** I can efficiently identify which members made which payments during the reconciliation process.

## Acceptance Criteria

1. The service must take parsed payment data and suggest potential GHL contact matches
2. The matching algorithm must compare payment amount against expected membership fees
3. The service must perform fuzzy name matching between transaction descriptions and contact names
4. The service must rank match suggestions by confidence score (highest probability first)
5. The service must handle cases where no reasonable matches are found (return empty suggestions)
6. The service must exclude contacts who already have recent reconciliation records to avoid duplicate matching
7. The service must return structured match suggestions with contact details and match reasoning
8. The service must be optimized for performance when processing multiple payments

## Tasks / Subtasks

- [x] Task 1: Create MatchingService class structure (AC: 1, 5, 8)
  - [x] Set up MatchingService.ts in src/lib/ directory
  - [x] Define TypeScript interfaces for match suggestions and scoring
  - [x] Implement core service structure with error handling
  - [x] Add performance optimization for batch processing

- [x] Task 2: Implement contact data preparation (AC: 1, 6)
  - [x] Load and cache GHL contacts for matching
  - [x] Filter out contacts with recent reconciliation records
  - [x] Prepare contact search index for name matching
  - [x] Handle contact data refresh strategies

- [x] Task 3: Implement payment amount matching (AC: 2)
  - [x] Define standard membership fee amounts and ranges
  - [x] Compare payment amounts against expected membership fees
  - [x] Score matches based on amount exactness and tolerance
  - [x] Handle special cases (partial payments, multiple fees)

- [x] Task 4: Implement fuzzy name matching (AC: 3, 4)
  - [x] Extract names from transaction descriptions using regex patterns
  - [x] Implement fuzzy string matching algorithm (Levenshtein distance)
  - [x] Score name matches with confidence weighting
  - [x] Handle common name variations (nicknames, initials, reversed names)

- [x] Task 5: Implement match scoring and ranking (AC: 4, 7)
  - [x] Combine amount and name match scores into overall confidence
  - [x] Rank suggestions by confidence score (highest first)
  - [x] Structure match results with contact details and reasoning
  - [x] Apply minimum confidence threshold for suggestions

- [x] Task 6: Add comprehensive testing (AC: All)
  - [x] Create unit tests for matching algorithms
  - [x] Test fuzzy name matching with various scenarios
  - [x] Test amount matching with different membership types
  - [x] Test ranking and confidence scoring
  - [x] Create integration tests with sample payment data

## Dev Notes

### Previous Story Insights
**Key learnings from Story 1.5** [Source: Story 1.5 completion notes]:
- ParsedPaymentData interface available with transactionFingerprint, amount, paymentDate, source, description
- CsvParsingService.ts provides structured payment data ready for matching
- ReconciliationLog model tracks reconciled transactions with transactionFingerprint
- PaymentSource model stores hashed account identifiers for future matching

### Data Models and Schema
**ReconciliationLog Model** [Source: docs/architecture/data-models-and-schema-changes.md]:
- Used to check for existing reconciliation records to avoid duplicate matching
- Key field: transactionFingerprint (unique) for duplicate detection
- contactId field links reconciled payments to matched contacts

**Contact Model** [Source: existing Prisma schema]:
- Contains firstName, lastName, name, email, phone for matching
- membershipType field indicates expected payment amounts
- customFields JSON contains additional member information

### Component Architecture
**MatchingService Location** [Source: docs/architecture/component-architecture.md]:
- File Location: src/lib/MatchingService.ts
- Purpose: Contains the "smart matching" logic against GHL contacts
- Integration: Called by API routes in src/app/api/reconciliation/matches/

### GHL API Integration
**Contact Data Access** [Source: src/lib/ghl-api.ts analysis]:
- fetchAllContactsFromGHL() function available for loading contact data
- mapGHLContactToPrisma() function for contact data mapping
- Contact names available via firstName, lastName, name fields
- membershipType field indicates membership category for amount matching

### Matching Algorithm Strategy
**Name Matching Approach**:
- Extract names from transaction descriptions using regex patterns
- Common patterns: "MEMBERSHIP - JOHN DOE", "RENEWAL JANE SMITH", "J SMITH PAYMENT"
- Use Levenshtein distance for fuzzy string matching
- Handle name variations: "John" vs "J", "Smith-Jones" vs "Smith Jones"
- Score based on similarity percentage and completeness

**Amount Matching Strategy**:
- Define standard membership fee ranges:
  - Full Membership: £20-30 annual range (Single £20, Double £30)
  - Associate Membership: £10 annual fee
  - Newsletter Only: £0 (free)
- Score exact matches highest, then within tolerance ranges
- Handle partial payments and multiple fee structures

**Confidence Scoring Formula**:
- Name match score (0-1) weighted at 60%
- Amount match score (0-1) weighted at 40% 
- Combined score threshold: 0.3 minimum for suggestions
- Return top 5 suggestions ranked by confidence

### Technical Context
**Technology Stack** [Source: docs/architecture/tech-stack-alignment.md]:
- TypeScript 5.9.2 for all new code
- Node.js built-in string matching capabilities
- Existing Prisma client for database access
- Performance considerations for batch processing

**Integration Points**:
- Uses ParsedPaymentData from CsvParsingService
- Integrates with existing GHL contact data
- Returns structured suggestions for API consumption
- Links to ReconciliationLog for duplicate prevention

### File Locations
**Implementation Files**:
- src/lib/MatchingService.ts - Main matching service
- src/lib/types/matching.ts - TypeScript interfaces (if needed)
- src/__tests__/lib/MatchingService.test.ts - Unit tests

**Integration Dependencies**:
- src/lib/CsvParsingService.ts - Payment data interface
- src/lib/ghl-api.ts - Contact data access
- src/lib/prisma.ts - Database client for ReconciliationLog checks

### Performance Considerations
- Cache GHL contact data in memory for multiple matching operations
- Implement efficient string matching algorithms
- Batch process multiple payments in single service call
- Use database indexes for reconciliation record lookups

### Testing Strategy
**Framework**: Jest & React Testing Library [Source: docs/architecture/tech-stack-alignment.md]
**Test Location**: src/__tests__/lib/ following established patterns

**Required Test Cases**:
- Exact name matches with various payment amounts
- Fuzzy name matching with common variations
- Amount matching across different membership types
- Confidence scoring and ranking accuracy
- Edge cases: no matches, multiple high-confidence matches
- Performance testing with large datasets
- Integration with ReconciliationLog duplicate checking

**Test Data Requirements**:
- Sample contact data with various name formats
- Payment data with different description patterns
- Edge case scenarios (empty names, unusual amounts)
- Performance test datasets (100+ contacts, 50+ payments)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-08 | 1.0 | Initial story creation for smart matching logic service | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4 (claude-sonnet-4-20250514)

### Debug Log References  
- No debug logs required for this implementation

### Completion Notes List
- Successfully implemented complete MatchingService with fuzzy name matching using Levenshtein distance algorithm
- Implemented comprehensive amount matching with membership type ranges (Full: £20-30, Associate: £10, Newsletter: £0)
- Added contact caching with 5-minute expiry for performance optimization during batch processing
- Implemented confidence scoring with 60% name weight, 40% amount weight, 0.3 minimum threshold
- Added comprehensive error handling with GHL API fallback to database contacts
- Created extensive test suite with 23 passing tests covering all acceptance criteria and edge cases
- Performance optimized for batch processing with contact data caching and efficient algorithms
- Implemented duplicate contact filtering based on recent reconciliation records (30-day window)

### File List
- src/lib/MatchingService.ts - Main matching service implementation
- src/__tests__/lib/MatchingService.test.ts - Comprehensive test suite with 23 tests

## QA Results

_Results from QA Agent review will be populated here after implementation._